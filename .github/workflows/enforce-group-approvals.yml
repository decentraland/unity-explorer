name: Enforce QA and DEV Approvals

on:
  pull_request:
    branches: [dev]
    types:
      - labeled
      - unlabeled
      - synchronize
      - review_requested
      - review_request_removed
  pull_request_review:
    types:
      - submitted
      - dismissed

jobs:
  enforce-approvals:
    if: >
      github.event.pull_request.draft == false &&
      github.event.review.state != 'changes_requested' &&
      github.event.pull_request.base.ref == 'dev'
    runs-on: ubuntu-latest

    steps:
      - name: Fetch PR Metadata
        env:
          GITHUB_TOKEN: ${{ github.token }}
          EVENT_PAYLOAD: ${{ toJSON(github.event) }}
        run: |
          echo "üîç Extracting PR details..."

          PR_NUMBER=$(jq -r '.pull_request.number' <<< "$EVENT_PAYLOAD")
          REPO_OWNER=$(jq -r '.repository.owner.login' <<< "$EVENT_PAYLOAD")
          REPO_NAME=$(jq -r '.repository.name' <<< "$EVENT_PAYLOAD")
          HEAD_SHA=$(jq -r '.pull_request.head.sha' <<< "$EVENT_PAYLOAD")

          echo "‚úÖ PR Number: $PR_NUMBER"
          echo "‚úÖ Repository: $REPO_OWNER/$REPO_NAME"
          echo "‚úÖ Head SHA: $HEAD_SHA"

          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
          echo "REPO_OWNER=$REPO_OWNER" >> $GITHUB_ENV
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_ENV

      - name: Validate Group Approvals
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
        run: |
          echo "üîç Checking PR labels..."
          LABELS_JSON=$(gh api "/repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUMBER/labels" --jq '.')

          if jq -r '.[].name' <<< "$LABELS_JSON" | grep -q "auto-pr"; then
            echo "‚úÖ Skipping approval validation due to 'auto-pr' label."
            exit 0
          fi

          echo "üîç Fetching team members..."
          QA_TEAM="qa"
          DEV_TEAM="explorer-devs"

          fetch_team_members() {
            local team_slug=$1
            gh api "/orgs/$REPO_OWNER/teams/$team_slug/members" --jq '.[].login'
          }

          QA_MEMBERS=$(fetch_team_members "$QA_TEAM")
          DEV_MEMBERS=$(fetch_team_members "$DEV_TEAM")

          echo "‚úÖ QA Team Members: ${QA_MEMBERS:-None}"
          echo "‚úÖ DEV Team Members: ${DEV_MEMBERS:-None}"

          echo "üîç Fetching PR reviews..."
          PR_REVIEWS_JSON=$(gh api "/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/reviews" --jq '.')
          PR_REVIEWS=$(jq -r '.[] | select(.state == "APPROVED") | .user.login' <<< "$PR_REVIEWS_JSON")
          echo "‚úÖ Approved Reviews (before filtering): ${PR_REVIEWS:-None}"

          echo "üîç Fetching pending review requests..."
          PENDING_REVIEWERS_JSON=$(gh api "/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/requested_reviewers" --jq '.')
          PENDING_REVIEWERS=$(jq -r '.users[].login' <<< "$PENDING_REVIEWERS_JSON" || echo "")
          echo "üî∏ Pending Reviewers: ${PENDING_REVIEWERS:-None}"

          # Ensure reviewers who have a pending review request are removed
          FILTERED_REVIEWS=()
          for reviewer in $PR_REVIEWS; do
            if echo "$PENDING_REVIEWERS" | grep -q "^$reviewer$"; then
              echo "‚ùå Removing $reviewer from approvals due to pending review request."
              continue
            fi
            FILTERED_REVIEWS+=("$reviewer")
          done

          echo "‚úÖ Approved Reviews (after removing pending reviewers): ${FILTERED_REVIEWS[*]:-None}"

          HAS_QA_APPROVAL=false
          HAS_DEV_APPROVAL=false

          for reviewer in "${FILTERED_REVIEWS[@]}"; do
            if echo "$QA_MEMBERS" | grep -q "^$reviewer$"; then
              HAS_QA_APPROVAL=true
            fi

            if echo "$DEV_MEMBERS" | grep -q "^$reviewer$"; then
              HAS_DEV_APPROVAL=true
            fi
          done

          if [ "$HAS_QA_APPROVAL" != true ] || [ "$HAS_DEV_APPROVAL" != true ]; then
            MISSING=()
            [ "$HAS_QA_APPROVAL" != true ] && MISSING+=("QA approval")
            [ "$HAS_DEV_APPROVAL" != true ] && MISSING+=("DEV approval")
            MISSING_MSG=$(IFS=", "; echo "${MISSING[*]}")
            echo "‚ùå PR must have at least 1: $MISSING_MSG."
            echo "APPROVAL_CHECK=failed" >> $GITHUB_ENV
            exit 1
          fi

          echo "‚úÖ PR has the required approvals."
          echo "APPROVAL_CHECK=passed" >> $GITHUB_ENV

      - name: Search Failed "Enforce QA and DEV Approvals" Run
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
        if: env.APPROVAL_CHECK == 'passed'
        run: |
          echo "üîé Finding workflow ID for 'Enforce QA and DEV Approvals'"
          WORKFLOW_ID=$(gh api "repos/$REPO_OWNER/$REPO_NAME/actions/workflows" --jq '.workflows[] | select(.name == "Enforce QA and DEV Approvals") | .id')
          echo "üìò Workflow ID: $WORKFLOW_ID"

          page=1
          WORKFLOW_RUN_ID=""

          while [ -z "$WORKFLOW_RUN_ID" ]; do
            echo "üìÑ Fetching page $page of workflow runs for workflow ID $WORKFLOW_ID..."
            RUNS=$(gh api "repos/$REPO_OWNER/$REPO_NAME/actions/workflows/$WORKFLOW_ID/runs?per_page=100&page=$page")

            # üïí Log created_at of the first run on this page
            FIRST_CREATED_AT=$(jq -r '.workflow_runs[0].created_at // "N/A"' <<< "$RUNS")
            echo "üïí First run on page $page was created at: $FIRST_CREATED_AT"

            MATCH=$(jq --arg HEAD_SHA "$HEAD_SHA" --argjson PR_NUMBER "$PR_NUMBER" '
              .workflow_runs[] |
              select(.head_sha == $HEAD_SHA) |
              select(.pull_requests | any(.number == $PR_NUMBER)) |
              select(.conclusion == "failure")
            ' <<< "$RUNS")

            if [ -n "$MATCH" ]; then
              WORKFLOW_RUN_ID=$(echo "$MATCH" | jq -r '.id')
              echo "üìå Found matching failed run: $WORKFLOW_RUN_ID"
              break
            fi

            # Stop if fewer than 100 runs returned (no more pages)
            if [ "$(jq '.workflow_runs | length' <<< "$RUNS")" -lt 100 ]; then
              echo "üö´ No matching failed workflow run found in available history."
              break
            fi

            page=$((page + 1))
          done

          if [ -z "$WORKFLOW_RUN_ID" ]; then
            echo "üî∏ No previous failed workflow run found for this commit on PR #${PR_NUMBER}."
            exit 0
          fi

          echo "üîÅ Triggering re-run for Workflow Run ID: $WORKFLOW_RUN_ID"
          echo "    ‚û§ Endpoint: POST /repos/$REPO_OWNER/$REPO_NAME/actions/runs/$WORKFLOW_RUN_ID/rerun"

          gh api -X POST "repos/$REPO_OWNER/$REPO_NAME/actions/runs/$WORKFLOW_RUN_ID/rerun" --verbose
          echo "‚úÖ Re-run triggered successfully!"
