//#pragma enable_d3d11_debug_symbols

#include "ScatterFunctions.cginc"

#pragma kernel FlowerScatter

struct PerInst
{
    float4 position;
    float4 quatRotation;
    float4 colour;
};

cbuffer ConstBuffer : register(b0)
{
    float4 TerrainBounds;
    int2 HeightTextureSize;
    int2 OccupancyTextureSize;
    int2 TerrainBlendTextureSize;
    int2 GroundDetailTextureSize;
    int2 SandDetailTextureSize;
    float TerrainHeight;
    int parcelSize;
    int nThreads;
    float fDistanceFieldScale;
    float nHeightMapSize;
    float fSplatMapTiling;
    float _MinDistOccupancy;
}

Texture2D<float4> HeightMapTexture : register(t0);
Texture2D<float4> OccupancyTexture : register(t1);
Texture2D<float4> TerrainBlendTexture : register(t2);
Texture2D<float4> GroundDetailTexture : register(t3);
Texture2D<float4> SandDetailTexture : register(t4);
StructuredBuffer<int2> visibleParcels : register(t5);
StructuredBuffer<uint> visibleParcelCount : register(t6);

RWStructuredBuffer<PerInst> flower0Instances : register(u0);
RWStructuredBuffer<PerInst> flower1Instances : register(u1);
shared RWStructuredBuffer<uint> drawArgs0 : register(u2);
shared RWStructuredBuffer<uint> drawArgs1 : register(u3);

#pragma multi_compile THREADS_64 THREADS_16

#if THREADS_64
[numthreads(64, 1, 1)]
#elif THREADS_16
[numthreads(16, 1, 1)]
#endif
void FlowerScatter(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID, uint3 localId : SV_GroupThreadID)
{
    if (groupId.x >= visibleParcelCount[0])
        return;

    const int nAxisLength = sqrt(nThreads);
    const int nMetrePerGrid = (float)parcelSize / nAxisLength;

    int2 corner0 = (int2)(visibleParcels[groupId.x] * parcelSize);
    half2 parcelGroupingArea = half2(hash_int_to_float(corner0), hash_int_to_float(-corner0));
    int2 gridPosition = int2((int)(localId.x % nAxisLength), (int)(localId.x / nAxisLength)) * nMetrePerGrid;

    float2 worldSpaceCoord_ParcelBlock = corner0 + gridPosition;
    float2 UV_coords_ParcelBlock = (worldSpaceCoord_ParcelBlock + (nHeightMapSize/2.0f)) / nHeightMapSize;

    // Check the texture
    half4 terrainColour = SplatmapMix(UV_coords_ParcelBlock * fSplatMapTiling, TerrainBlendTexture, GroundDetailTexture, SandDetailTexture, nMetrePerGrid>>1);

    PerInst perInst;
    
    if (terrainColour.g < 0.08f)
    {
        half random_X_flower0 = (hash_int_to_float(corner0 + gridPosition) * nMetrePerGrid);
        half random_Z_flower0 = (hash_int_to_float(-corner0 + gridPosition) * nMetrePerGrid);

        half random_X_flower1 = random_Z_flower0;
        half random_Z_flower1 = random_X_flower0;

        random_X_flower0 *= nAxisLength;
        random_Z_flower0 *= nAxisLength;
        random_X_flower1 *= nAxisLength; 
        random_Z_flower1 *= nAxisLength; 
        
        // Get Height
        float2 UV_coords_0 = (corner0 + float2(random_X_flower0, random_Z_flower0) + (nHeightMapSize/2.0f)) / nHeightMapSize;
        float height_flower0 = CalculateHeightFromHeightmap(UV_coords_0, fDistanceFieldScale, nHeightMapSize, parcelSize, OccupancyTextureSize.x, HeightMapTexture, OccupancyTexture, _MinDistOccupancy);
        float2 UV_coords_1 = (corner0 + float2(random_X_flower1, random_Z_flower1) + (nHeightMapSize/2.0f)) / nHeightMapSize;
        float height_flower1 = CalculateHeightFromHeightmap(UV_coords_1, fDistanceFieldScale, nHeightMapSize, parcelSize, OccupancyTextureSize.x, HeightMapTexture, OccupancyTexture, _MinDistOccupancy);
    
        float fScale0 = 1.0f + (2.0f * hash_int_to_float(corner0 + float2(random_X_flower0, random_Z_flower0) + localId.x));
        float fScale1 = 1.0f + (2.0f * hash_int_to_float(corner0 + float2(random_X_flower1, random_Z_flower1) + localId.x));
        
        float3 normalWS_0 = CalculateNormalFromHeightmap(UV_coords_0, fDistanceFieldScale, HeightMapTexture, OccupancyTexture, _MinDistOccupancy);
        float3 normalWS_1 = CalculateNormalFromHeightmap(UV_coords_1, fDistanceFieldScale, HeightMapTexture, OccupancyTexture, _MinDistOccupancy);
        
        InterlockedAdd(drawArgs0[1], 1);
        perInst.position = float4(random_X_flower0, height_flower0, random_Z_flower0, fScale0);
        perInst.quatRotation = CreateGrassRotationQuaternion(normalWS_0, hash_int_to_float(corner0 + gridPosition) * 2.0f);
        perInst.colour = float4(1.0, 1.0, 1.0, 1.0);
        flower0Instances[id.x] = perInst;
        
        InterlockedAdd(drawArgs1[1], 1);
        perInst.position = float4(random_X_flower1, height_flower1, random_Z_flower1, fScale1);
        perInst.quatRotation = CreateGrassRotationQuaternion(normalWS_1, hash_int_to_float(corner0 + gridPosition) * 2.0f);
        perInst.colour = float4(1.0, 1.0, 1.0, 1.0);
        flower1Instances[id.x] = perInst;
    }
    else
    {
        perInst.position = float4(0.0f, -5000.0f, 0.0f, 0.0f);
        perInst.quatRotation = float4(0.0f, 0.0f, 0.0f, 0.0f);
        perInst.colour = float4(0.0f, 0.0f, 0.0f, 0.0f);
        InterlockedAdd(drawArgs0[1], 1);
        InterlockedAdd(drawArgs1[1], 1);
        flower0Instances[id.x] = perInst;
        flower1Instances[id.x] = perInst;
    }
}
