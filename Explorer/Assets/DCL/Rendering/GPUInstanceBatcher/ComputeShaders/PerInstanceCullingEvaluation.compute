#include "Includes/PlatformSpecifications.cginc"
#include "Includes/CullingFunctions.cginc"
#include "Includes/CameraFunctions.cginc"

#pragma enable_d3d11_debug_symbols
#pragma kernel CameraCullingAndLODCalculationKernel

////////////////////
// UNIFORM INPUTS
////////////////////

// PerInstance
struct PerInstance
{
    float4x4 worldMatrix;
    float4 colour;
};
shared RWStructuredBuffer<PerInstance> PerInstanceData;

struct GroupData
{
    float4x4 lodSizes;
    float4x4 matCamera_MVP;
    float3 vCameraPosition;
    float fShadowDistance;
    float3 vBoundsCenter;
    float frustumOffset;
    float3 vBoundsExtents;
    float fCameraHalfAngle;
    float fMaxDistance;
    float minCullingDistance;
    uint nInstBufferSize;
    uint nMaxLOD_GB;
};
StructuredBuffer<GroupData> GroupDataBuffer;

// Occlusion
// uniform bool isOcclusionCulling;
// uniform float occlusionOffset;
// uniform uint occlusionAccuracy;
// uniform float4 hiZTxtrSize;
// uniform Texture2D<float4> hiZMap;
// uniform SamplerState sampler_hiZMap;


////////////////////
// UNIFORM OUTPUTS
////////////////////
RWStructuredBuffer<uint4> PerInstance_LODLevels; // LOD_A, LOD_B, LOD_Dither, LOD_Shadow 

[numthreads(GPUI_THREADS, 1, 1)]
void CameraCullingAndLODCalculationKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GroupDataBuffer[0].nInstBufferSize)
        return;

    uint4 nOutput4 = uint4(8,8,0,8);

    float fDistance;
    float fScreenSpaceSize;
    const float4x4 mInstMatrix = PerInstanceData[id.x].worldMatrix;
    EvaluateInstanceDistance(mInstMatrix, fDistance, fScreenSpaceSize, GroupDataBuffer[0].vBoundsExtents, GroupDataBuffer[0].vCameraPosition, GroupDataBuffer[0].fCameraHalfAngle);
    
    bool bCulled = false;
    
    // Distance culling
    if (fDistance >= GroupDataBuffer[0].fMaxDistance)
    {
        bCulled = true;
    }

    if (bCulled == false && fDistance >= GroupDataBuffer[0].minCullingDistance)
    {
        float4 BoundingBox[8];
        CalculateBoundingBox(mInstMatrix, BoundingBox, GroupDataBuffer[0].matCamera_MVP, GroupDataBuffer[0].vBoundsCenter, GroupDataBuffer[0].vBoundsExtents);
        
        bCulled = IsFrustumCulled(BoundingBox, GroupDataBuffer[0].frustumOffset);

    
        // Hierarchical Z-Buffer Occlusion Culling      
        // if (bCulled == false && isOcclusionCulling)
        // {
        //     bCulled = IsOcclusionCulled(BoundingBox, hiZTxtrSize, occlusionOffset, occlusionAccuracy,hiZMap, sampler_hiZMap);
        // }
    }

    if (bCulled == false)
    {
        nOutput4 = EvaluateLODLevel(GroupDataBuffer[0].nMaxLOD_GB, GroupDataBuffer[0].lodSizes, GroupDataBuffer[0].fShadowDistance, fScreenSpaceSize, fDistance);
    }

    PerInstance_LODLevels[id.x] = nOutput4;
}