// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)

// Generic compute skinning ... with pos, norm, and tangent skinning
// for readability, deleted multi compile codes from original

#pragma kernel main

#include "HLSLSupport.cginc"

uint g_VertCount;
SAMPLER_UNIFORM StructuredBuffer<float4x4> g_mBones;

struct SVertInVBO
{
    float3 pos;
    float3 norm;
    float4 tang;
};
SAMPLER_UNIFORM StructuredBuffer<SVertInVBO> g_SourceVBO;


struct SVertInSkin
{
    float weight0,weight1,weight2,weight3;
    int index0,index1,index2,index3;
};
SAMPLER_UNIFORM StructuredBuffer<SVertInSkin> g_SourceSkin;


struct SVertOut
{
    float3 pos;
    float3 norm;
    float4 tang;
};
SAMPLER_UNIFORM RWStructuredBuffer<SVertOut> g_MeshVertsOut;

#define NR_THREADS  64

[numthreads(NR_THREADS, 1, 1)]
void main(uint3 threadID : SV_DispatchThreadID)
{
    const uint t = threadID.x;

    if (t >= g_VertCount)
    {
        return;
    }
    
    const SVertInVBO vert = g_SourceVBO[t];
    SVertInSkin si = g_SourceSkin[t];           // get skinning info.
    float3 vP = vert.pos.xyz;
    float3 vPacc = float3(0,0,0);

    float3 vN = float3(0,0,0);
    vN = vert.norm.xyz;
    float3 vNacc = float3(0,0,0);

    float3 vT = float3(0,0,0);
    vT = vert.tang.xyz;
    float3 vTacc = float3(0,0,0);
    
    vPacc += si.weight0*mul(  g_mBones[si.index0], float4(vP,1) ).xyz;
    vPacc += si.weight1*mul(  g_mBones[si.index1], float4(vP,1) ).xyz;
    vPacc += si.weight2*mul(  g_mBones[si.index2], float4(vP,1) ).xyz;
    vPacc += si.weight3*mul(  g_mBones[si.index3], float4(vP,1) ).xyz;
    
    vNacc += si.weight0*mul(  g_mBones[si.index0],float4(vN,0) ).xyz;
    vNacc += si.weight1*mul(  g_mBones[si.index1],float4(vN,0) ).xyz;
    vNacc += si.weight2*mul(  g_mBones[si.index2],float4(vN,0) ).xyz;
    vNacc += si.weight3*mul(  g_mBones[si.index3],float4(vN,0) ).xyz;
    
    vTacc += si.weight0*mul((float3x3)g_mBones[si.index0], vT  ).xyz;
    vTacc += si.weight1*mul((float3x3)g_mBones[si.index1], vT  ).xyz;
    vTacc += si.weight2*mul((float3x3)g_mBones[si.index2], vT  ).xyz;
    vTacc += si.weight3*mul((float3x3)g_mBones[si.index3], vT  ).xyz;

    vP = vPacc;
    g_MeshVertsOut[t].pos.xyz = vP;
    vN = vNacc;
    g_MeshVertsOut[t].norm.xyz = vN;
    vT = vTacc;
    g_MeshVertsOut[t].tang = float4(vT.xyz,vert.tang.w);
}