// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)

// Generic compute skinning ... with pos, norm, and tangent skinning
// for readability, deleted multi compile codes from original

#pragma kernel main

#include "HLSLSupport.cginc"

uint g_VertCount;

struct SVertInVBO
{
    float3 pos;
    float3 norm;
    float4 tang;
};


struct SVertInSkin
{
    float weight0,weight1,weight2,weight3;
    int index0,index1,index2,index3;
};


struct SVertOut
{
    float3 pos;
    float3 norm;
    float4 tang;
};

#define NR_THREADS  64

[numthreads(NR_THREADS, 1, 1)]
void main(uint3 threadID : SV_DispatchThreadID, SAMPLER_UNIFORM StructuredBuffer<SVertInVBO> g_SourceVBO, SAMPLER_UNIFORM StructuredBuffer<SVertInSkin> g_SourceSkin, SAMPLER_UNIFORM RWStructuredBuffer<SVertOut> g_MeshVertsOut,
            SAMPLER_UNIFORM StructuredBuffer<float4x4> g_mBones, SAMPLER_UNIFORM StructuredBuffer<float4x4> g_BindPoses, SAMPLER_UNIFORM StructuredBuffer<int> g_BindPosesIndex)
{
    const uint t = threadID.x;

    if (t >= g_VertCount)
    {
        return;
    }
    
    const SVertInVBO vert = g_SourceVBO[t];
    SVertInSkin si = g_SourceSkin[t];           // get skinning info.
    float3 vP = vert.pos.xyz;
    float3 vPacc = float3(0,0,0);
    
    const int baseIndex = g_BindPosesIndex[t];
    vPacc += si.weight0 * mul(g_mBones[si.index0], mul(g_BindPoses[baseIndex+si.index0], float4(vP, 1))).xyz;
    vPacc += si.weight1 * mul(g_mBones[si.index1], mul(g_BindPoses[baseIndex+si.index1], float4(vP, 1))).xyz;
    vPacc += si.weight2 * mul(g_mBones[si.index2], mul(g_BindPoses[baseIndex+si.index2], float4(vP, 1))).xyz;
    vPacc += si.weight3 * mul(g_mBones[si.index3], mul(g_BindPoses[baseIndex+si.index3], float4(vP, 1))).xyz;
    
    vP = vPacc;
    g_MeshVertsOut[t].pos.xyz = vP;
}