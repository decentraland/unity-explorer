import * as path from 'path'
import { promisify } from 'util'
import { exec } from 'child_process'
import { glob } from 'glob'
import {
  camelToSnakeCase,
  cleanGeneratedCode,
  execute,
  normalizePath,
  protocolOutputPath,
  protocolPath,
  protocPath,
  workingDirectory,
} from './helpers'
import * as fs from 'node:fs'
import * as fse from 'fs-extra'

const protocolRawInputPath = normalizePath(path.resolve(protocolPath))

const protocolInputPath = normalizePath(
  path.resolve(__dirname, '../temp/'),
)

async function main() {
  if (fs.existsSync(protocolInputPath)) {
    fs.rmSync(protocolInputPath, { recursive: true })
  }

  fse.copySync(protocolRawInputPath, protocolInputPath, {
    overwrite: true,
  })

  await execute(`${protocPath} --version`, workingDirectory)

  await buildProtocol()

  fs.rmSync(protocolInputPath, { recursive: true })
}

const regex = new RegExp(/option *\(common.ecs_component_id\) *= *([0-9]+) *;/)

const getComponentId = (text: string): string | null => {
  const res = text.match(regex)
  if (res && res.length >= 1) return res[1]
  return null
}

type ComponentData = { componentName: string; componentId: number }

function generateComponentsEnum(components: ComponentData[]) {
  components.sort((first, second) => first.componentId - second.componentId)
  let content: string = ''

  content += '/* Autogenerated file, DO NOT EDIT! */\n'
  content += 'namespace DCL.ECS7\n'
  content += '{\n'
  content += '    public static class ComponentID \n'
  content += '    {\n'

  content += '        public const int TRANSFORM = 1;\n'
  for (const component of components) {
    let componentUpperCaseName = camelToSnakeCase(
      component.componentName,
    ).toUpperCase()

    content += `        public const int ${componentUpperCaseName} = ${component.componentId.toString()};\n`
  }
  content += '    }\n'
  content += '}\n'

  const outputPath = path.resolve(protocolOutputPath, 'ComponentID.gen.cs')
  fs.writeFileSync(outputPath, content)
}

async function preProcessComponents() {
  const protoFiles = glob.sync(
    normalizePath(
      path.resolve(protocolInputPath, 'decentraland/sdk/components/**/*.proto'),
    ),
  )
  const components: ComponentData[] = []

  for (const file of protoFiles) {
    const content = fs.readFileSync(file).toString()
    const lines = content.split('\n')
    const outputLines = new Array<string>()
    let newComponentId = null

    for (const line of lines) {
      const componentId = getComponentId(line)
      if (componentId) {
        newComponentId = Number(componentId)
      } else if (line.indexOf('common/id.proto') == -1) {
        outputLines.push(line)
      }
    }

    outputLines.push('option csharp_namespace = "DCL.ECSComponents";')

    if (newComponentId) {
      const fileName = path.basename(file)
      const componentName = fileName.replace('.proto', '')
      components.push({
        componentId: newComponentId,
        componentName,
      })
    }

    fs.writeFileSync(file, outputLines.join('\n'))
  }

  generateComponentsEnum(components)
}

function getProtofiles(pattern: string)
{
  return glob
    .sync(
      normalizePath(path.resolve(protocolInputPath, pattern)),
    )
}

const execAsync = promisify(exec)

async function buildProtocol() {
  console.log('Building protocol...')
  cleanGeneratedCode(protocolOutputPath)

  await preProcessComponents()

  const protoFiles = getProtofiles('decentraland/**/*.proto')
      .filter((value) => !value.endsWith('id.proto'))
      .filter((value) => !value.endsWith('v1/comms.proto'))
      .filter((value) => !value.endsWith('v2/comms.proto'))
      .filter((value) => !value.endsWith('v3/comms.proto'))

  const baseCommand = `${protocPath} --csharp_out "${protocolOutputPath}" --csharp_opt=file_extension=.gen.cs --proto_path "${protocolInputPath}"`

  // Split protoFiles into chunks
  const chunkSize = 10
  for (let i = 0; i < protoFiles.length; i += chunkSize) {
    const chunk = protoFiles.slice(i, i + chunkSize)
    const command = `${baseCommand} ${chunk.join(' ')}`

    try {
      await execAsync(command, { cwd: workingDirectory })
    } catch (error) {
      console.error(`Error executing command: ${error}`)
      throw error
    }
  }

  console.log('Building protocol... Done!')
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
